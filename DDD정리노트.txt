효과적으로 모델링을 하려면
1. 모델과 구현이 연계되어야한다.
? 이게 무슨 의미이지.. 모델 설계할 때 구현을 신경써야 하는 건가 ?
2. 모델 기반의 언어정제(유비쿼터스 언어)
3. 도메인 지식이 담긴 모델 개발
4. 모델 정제(불필요한 부분을 제거)
5. 브레인스토밍과 실험

유비쿼터스 언어
-> 실제 도메인에서 사용하는 단어/개념
-> 유비쿼터스 언어가 바뀌면 모델이 바뀌어야 한다.
-> 실제 의사소통을 할 때 유비쿼터스 언어를 사용해야 한다.

소통하는 방법
-> 공통 언어를 사용한다.
-> 모델은 다이어그램이 아니다.
-> 문서는 코드와 말을 보완한다. 프로그램의 동작을 문서로 상세희 기술하는 것은 좋지않다.
-> 설계나 세부 사항은 코드에 담겨있다.

엔티티
-> id가 존재함. id가 같아야 같은 객체.
밸류 오브젝트
-> 속성이 같으면 같은 객체

서비스
-> 도메인에 객체로는 모델에 어울리지 않는 것들이 있음.
-> 클라이언트에 뭘 제공할 수 있는지가 기준
-> 서비스는 상태를 갖지 않는다.
? 이게 정확이 뭘까 ?
? MSA의 S는 이걸 뜻하는 건가 ? 

어그리게이션(집합체)
-> 복합객체를 표현하는 방법
-> 루트만 참조 가능하다. 루트안에 있는건 루트를 통해서.
-> 내부의 복잡성을 관리할 수 있음.

팩터리
-> 복잡한 어그리게이션을 생성하는 것은 생성된 객체의 책임으로 어울리지 않음.
-> 그렇다고 클라이언트에 생성하는걸 맞길 수도 없음.
-> 이 책임을 다른객체에 위임해라.
? 이런 방법들을 어떻게 FP를 적용해야 될까 ?

레포지터리
-> 특정 객체를 참조하는 방법
-> 기존 ORM이나 DB대신 이 친구를 쓴다
-> 객체 생명주기에서 재생성을 맡고있음
-> DB에 접근하는 친구를 캡슐화

바운디드 컨텍스트
-> 크고 복잡한 시스템을보다 관리하기 쉬운 조각으로 분해하는 방법
-> 도메인 모델을 일관되게 적용하는 방법.

-> 도메인 모델을 팀마다 적용하다보면 다른 모델을 사용하게 되는 경우가 있다.
-> 이런 경우 모델이 유효한 범위를 정해주면 됨.
-> 큰 시스템은 여러개의 바운디드 컨텍스트로 이루어짐.
-> 바운디드 컨텍스트 마다 유비쿼터스 언어를 정의한다.

-> 그리고 각각의 컨텍스트간의 상호작용을 정한다.
-> 상호작용을 하는 방식은 이벤트를 발생시키는 것이다.
? 그러면 작은 시스템에서는 바운디드 컨텍스트가 의미 없는걸까 ?
? MSA + DDD에서 한명이 여러 서비스를 맡아서 작업하게 되는 경우 바운디드 컨텍스트가 달라질 수 있을 것 같은데 ?
? 그 때 유비쿼터스 랭귀지가 바뀌면 개발자가 도메인 전문가와 의사소통하는데 헷갈리지않으려나 ?

퍼블리쉬드 랭귀지
-> 두 바운디드 컨텍스트간에 이루어지는 반역에는 공통의 언어가 필요함.

